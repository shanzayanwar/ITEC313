import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.layout.*;
import javafx.geometry.*;
import javafx.stage.Stage;

import java.util.*;

public class FibonacciBucketApp extends Application {

    private List<Long> fibSequence = new ArrayList<>();
    private Map<Integer, List<Long>> buckets = new LinkedHashMap<>();
    private TextArea outputArea;
    private TextArea bucketArea;
    private TextField lengthField;
    private TextField searchField;
    private Label resultLabel;
    private Button genButton;
    private Button sortButton;
    private Button searchButton;
    private CheckBox evenFilter;
    private CheckBox oddFilter;

    @Override
    public void start(Stage primaryStage) {
        primaryStage.setTitle("Fibonacci Generator");

        // Input for sequence length
        Label lengthLabel = new Label("Enter sequence length:");
        lengthField = new TextField("40");
        genButton = new Button("Fib Gen");
        genButton.setOnAction(e -> generateFibonacci());

        // Filters
        evenFilter = new CheckBox("Even only");
        oddFilter = new CheckBox("Odd only");

        // Output area
        outputArea = new TextArea();
        outputArea.setEditable(false);
        outputArea.setPrefRowCount(4);

        // Bucket area
        bucketArea = new TextArea();
        bucketArea.setEditable(false);
        bucketArea.setPrefRowCount(10);

        // Buttons for bucket sort and search
        sortButton = new Button("Fib Bucket Sort");
        sortButton.setDisable(true);
        sortButton.setOnAction(e -> performBucketSort());

        searchField = new TextField();
        searchField.setPromptText("Enter number to search");
        searchButton = new Button("Fib Bucket Search");
        searchButton.setDisable(true);
        searchButton.setOnAction(e -> performBucketSearch());

        resultLabel = new Label();

        // Layout setup
        HBox inputBox = new HBox(10, lengthLabel, lengthField, genButton);
        inputBox.setAlignment(Pos.CENTER_LEFT);

        HBox filterBox = new HBox(10, evenFilter, oddFilter);
        filterBox.setAlignment(Pos.CENTER_LEFT);

        HBox searchBox = new HBox(10, new Label("Search number:"), searchField, searchButton);
        searchBox.setAlignment(Pos.CENTER_LEFT);

        VBox layout = new VBox(10);
        layout.setPadding(new Insets(15));
        layout.getChildren().addAll(
                new Label("Fibonacci Generator"),
                inputBox,
                filterBox,
                new Label("Generated sequence:"),
                outputArea,
                sortButton,
                new Label("Buckets:"),
                bucketArea,
                searchBox,
                resultLabel
        );

        Scene scene = new Scene(layout, 650, 600);
        primaryStage.setScene(scene);
        primaryStage.show();
    }

    // Task 1: Generate Fibonacci numbers with filters
    private void generateFibonacci() {
        fibSequence.clear();
        buckets.clear();
        bucketArea.clear();
        resultLabel.setText("");
        searchButton.setDisable(true);
        sortButton.setDisable(false);

        int length;
        try {
            length = Integer.parseInt(lengthField.getText());
            if (length <= 0) throw new NumberFormatException();
        } catch (NumberFormatException e) {
            outputArea.setText("Please enter a valid positive number for sequence length.");
            return;
        }

        // Generate Fibonacci sequence
        fibSequence.add(0L);
        fibSequence.add(1L);
        for (int i = 2; i < length; i++) {
            fibSequence.add(fibSequence.get(i - 1) + fibSequence.get(i - 2));
        }

        // Apply filters
        List<Long> filtered = new ArrayList<>(fibSequence);
        if (evenFilter.isSelected() && !oddFilter.isSelected()) {
            filtered.removeIf(n -> n % 2 != 0);
        } else if (oddFilter.isSelected() && !evenFilter.isSelected()) {
            filtered.removeIf(n -> n % 2 == 0);
        }

        outputArea.setText(filtered.toString());
        fibSequence = filtered;
    }

    // Task 2: Custom Bucket Sort
    private void performBucketSort() {
        buckets.clear();

        // Create buckets 2â€“9 and one non-divisible (bucket 9)
        for (int i = 2; i <= 9; i++) {
            buckets.put(i, new ArrayList<>());
        }
        buckets.put(10, new ArrayList<>()); // bucket 10 = non-divisible

        // Assign each Fibonacci number
        for (Long num : fibSequence) {
            boolean divisible = false;
            for (int divisor = 9; divisor >= 2; divisor--) {
                if (num % divisor == 0) {
                    buckets.get(divisor).add(num);
                    divisible = true;
                    break;
                }
            }
            if (!divisible) {
                buckets.get(10).add(num);
            }
        }

        // Display buckets
        StringBuilder sb = new StringBuilder();
        for (Map.Entry<Integer, List<Long>> entry : buckets.entrySet()) {
            String bucketName = (entry.getKey() == 10) ? "Non-divisible" : "Bucket " + entry.getKey();
            sb.append(bucketName).append(": ").append(entry.getValue()).append("\n");
        }
        bucketArea.setText(sb.toString());
        searchButton.setDisable(false);
    }

    // Task 3: Search for a number in the buckets
    private void performBucketSearch() {
        resultLabel.setText("");

        String input = searchField.getText().trim();
        if (input.isEmpty()) {
            resultLabel.setText("Please enter a number to search.");
            return;
        }

        long target;
        try {
            target = Long.parseLong(input);
        } catch (NumberFormatException e) {
            resultLabel.setText("Invalid number format.");
            return;
        }

        // Search through all buckets
        for (Map.Entry<Integer, List<Long>> entry : buckets.entrySet()) {
            List<Long> list = entry.getValue();
            int index = list.indexOf(target);
            if (index != -1) {
                String bucketName = (entry.getKey() == 10) ? "Non-divisible" : "Bucket " + entry.getKey();
                resultLabel.setText(target + " is in " + bucketName + ", position " + (index + 1) + ".");
                return;
            }
        }

        resultLabel.setText("Number not found!");
    }

    public static void main(String[] args) {
        launch(args);
    }
}
